# import Librarys that we need
import tkinter as tk
from tkinter import filedialog, messagebox
import pandas as pd
import os

class ExcelProcessor:
    def __init__(self, root):
        self.root = root
        self.root.title("Excel Processor")
        
        # Label for prompting user to select an Excel file
        self.label = tk.Label(root, text="Select an Excel file to process:")
        self.label.pack(pady=10)
        
        # Button to select the Excel file
        self.select_button = tk.Button(root, text="Select Excel File", command=self.select_excel_file)
        self.select_button.pack(pady=5)
        
        # Button to process the selected Excel file and save as a new Excel file
        self.process_button = tk.Button(root, text="Process and Save as Excel", command=self.process_and_save, state=tk.DISABLED)
        self.process_button.pack(pady=5)
        
        # Button to open the processed Excel file
        self.open_button = tk.Button(root, text="Open Processed File", command=self.open_processed_file, state=tk.DISABLED)
        self.open_button.pack(pady=5)
        
        # Status label to display current status or errors
        self.status_label = tk.Label(root, text="")
        self.status_label.pack(pady=10)
        
        # Initialize variables to hold file path and data
        self.excel_file_path = None
        self.processed_file_path = None
        self.data = None
        
    def select_excel_file(self):
        self.excel_file_path = filedialog.askopenfilename(filetypes=[("Excel files", "*.xls;*.xlsx")])
        if self.excel_file_path:
            self.status_label.config(text=f"Selected Excel file: {os.path.basename(self.excel_file_path)}")
            self.process_button.config(state=tk.NORMAL)
        else:
            self.status_label.config(text="No Excel file selected")
            self.process_button.config(state=tk.DISABLED)
    
    def process_and_save(self):
        try:
            # Read Excel file
            df = pd.read_excel(self.excel_file_path)
            
            # Filter requirements where LK_ContentType is 'Req'
            filter_requirements = df[df['LK_ContentType'] == 'Req']
            
            # Step 1: Identify rows with more than one value in LK_SWC
            mask = filter_requirements['LK_SWC'].str.contains('\n')
            
            # Step 1: Add the parent reference column
            filter_requirements['Parent Requirement ID'] = filter_requirements['ID']
            
            # Step 2: Separate these values into individual rows
            def split_and_expand(my_df, column, sep):
                """
                Splits the specified column by the given separator and expands the DataFrame.

                Args:
                - my_df: DataFrame to be processed.
                - column: Column name to split.
                - sep: Separator to split by.

                Returns:
                - DataFrame with expanded rows.
                """
                # Split the specified column by the separator and stack to get a Series
                s = my_df[column].str.split(sep).apply(pd.Series, 1).stack()
                s.index = s.index.droplevel(-1)  # to line up with df's index
                s.name = column
                del my_df[column]  # drop the original column
                # Join the new Series to the original DataFrame
                return my_df.join(s)
            
            # Apply the function to the rows where mask is True
            expanded_df = split_and_expand(filter_requirements[mask], 'LK_SWC', '\n')
            
            # Combine with the rows where mask is False
            combined_df = pd.concat([filter_requirements[~mask], expanded_df], ignore_index=True)
            
            # Combine with the original df to get the Final dataframe
            final_df = pd.concat([df, combined_df], ignore_index=True)
            
            # Ask user for save location
            save_path = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel files", "*.xlsx")])
            if save_path:
                final_df.to_excel(save_path, index=False)
                self.processed_file_path = save_path
                self.status_label.config(text=f"File successfully processed and saved as {os.path.basename(save_path)}")
                self.open_button.config(state=tk.NORMAL)
            else:
                self.status_label.config(text="Save operation cancelled")
        
        except Exception as e:
            self.status_label.config(text=f"Error: {str(e)}")
            messagebox.showerror("Error", f"An error occurred: {str(e)}")
    
    def open_processed_file(self):
        if self.processed_file_path:
            try:
                os.startfile(self.processed_file_path)
            except OSError:
                messagebox.showerror("Error", "Failed to open the processed file.")
        else:
            messagebox.showinfo("Information", "No processed file to open.")
        

# Create the Tkinter application window
root = tk.Tk()
app = ExcelProcessor(root)
root.mainloop()